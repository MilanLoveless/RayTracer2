// Iridescent.cpp
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "Iridescent.h"

namespace ThreeD
{
	_IRIDESCENT::_IRIDESCENT()
		: _BRDF(),
		kd(0.0),
		cd(0.0),
		p_i(1.0),
		r_i(1.0)
	{}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_IRIDESCENT::_IRIDESCENT(const _IRIDESCENT &lambert)
		:_BRDF(lambert),
		kd(lambert.kd),
		cd(lambert.cd)
	{}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_IRIDESCENT& _IRIDESCENT::operator= (const _IRIDESCENT &lambert)
	{
		if(this == &lambert)
			return (*this);
		
		kd = lambert.kd;
		cd = lambert.cd;

		return(*this);
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_IRIDESCENT::~_IRIDESCENT() {}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_IRIDESCENT* _IRIDESCENT::_Clone()
	{
		return (new _IRIDESCENT(*this));
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_COLOR4F _IRIDESCENT::_SampleF(const _SHADEREC &sr, const _VERTEX4F &wo, _VERTEX4F &wi, _DOUBLE &pdf)
	{
		_VERTEX4F w = sr.normal;
		_VERTEX4F v = w._CrossProduct(_VERTEX4F(0.0034, 1.0, 0.0071, 0.0), w);
		v._Normalize();
		_VERTEX4F u = w._CrossProduct(v, w);

		_VERTEX4F sp = sampler_ptr->_SampleHemisphere();
		wi = u * sp.x + v * sp.y + w * sp.z;
		wi._Normalize();

		pdf = wi._DotProduct(sr.normal, wi) * INV_PI;

		return (cd * kd * INV_PI);
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_COLOR4F _IRIDESCENT::_F(const _SHADEREC &sr, const _VERTEX4F &wo, const _VERTEX4F &wi)
	{
		_DOUBLE ndotwo = 1.0 - sr.normal._DotProduct(sr.normal, wo);
		_VERTEX4F v(cd.r, cd.g, cd.b, 0.0);
		_VERTEX4F k(1.0, 1.0, 1.0, 0.0);
		k._Normalize();
		ndotwo = pow(ndotwo, p_i);
		_VERTEX4F v1 = (v * cos(r_i*ndotwo*TWO_PI) + k._CrossProduct(k, v)*sin(r_i*ndotwo*TWO_PI) + k * k._DotProduct(k, v) * (1.0 - cos(r_i*ndotwo*TWO_PI)));
		_COLOR4F iridescent = _COLOR4F(1.0, v1.x, v1.y, v1.z);
		return (iridescent * kd * INV_PI);
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_COLOR4F _IRIDESCENT::_Rho(const _SHADEREC &sr, const _VERTEX4F &wo)
	{
		return (cd * kd);
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void _IRIDESCENT::_SetCD(const _COLOR4F c)
	{
		cd = c;
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void _IRIDESCENT::_SetKA(float k)
	{
		kd = k;
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void _IRIDESCENT::_SetKD(float k)
	{
		kd = k;
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void _IRIDESCENT::_SetPower(const _DOUBLE p)
	{
		p_i = p;
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void _IRIDESCENT::_SetRot(const _DOUBLE rot)
	{
		r_i = rot;
	}
}