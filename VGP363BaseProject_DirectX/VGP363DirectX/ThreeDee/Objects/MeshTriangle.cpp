// MeshTriangle.cpp
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "MeshTriangle.h"

namespace ThreeD
{
	_MESHTRIANGLE::_MESHTRIANGLE()
		: _GEOMETRICOBJECT(),
		mesh_ptr(NULL),
		p0(0), p1(0), p2(0),
		n0(0), n1(0), n2(0),
		uv0(0), uv1(0), uv2(0),
		area(0.0), normal(0.0, 0.0, 1.0, 0.0)
	{}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_MESHTRIANGLE::_MESHTRIANGLE(const _MESHTRIANGLE &tri)
		: _GEOMETRICOBJECT(),
		mesh_ptr(tri.mesh_ptr),
		p0(0), p1(0), p2(0),
		n0(0), n1(0), n2(0),
		uv0(0), uv1(0), uv2(0)
	{
		_CalculateNormal(false);
		_CalculateArea();
	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_MESHTRIANGLE::~_MESHTRIANGLE() {}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_VERTEX4F _MESHTRIANGLE::_GetNormal()
	{
		return normal;
	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_MESHTRIANGLE& _MESHTRIANGLE::operator= (const _MESHTRIANGLE &tri)
	{
		if(this == &tri)
			return (*this);
		
		_GEOMETRICOBJECT::operator=(tri);
		mesh_ptr = tri.mesh_ptr;
		p0 = tri.p0; p1 = tri.p1; p2 = tri.p2;
		n0 = tri.n0; n1 = tri.n1; n2 = tri.n2;
		uv0 = tri.uv0; uv1 = tri.uv1; uv2 = tri.uv2;
		normal = tri.normal;

		return (*this);
	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void _MESHTRIANGLE::_CalculateNormal(bool reversed)
	{
		normal = normal._CrossProduct(mesh_ptr->vertex_buffer[p1] - mesh_ptr->vertex_buffer[p0], mesh_ptr->vertex_buffer[p2] - mesh_ptr->vertex_buffer[p0]);
		normal._Normalize();
		if(reversed) normal = normal * -1.0;
	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void _MESHTRIANGLE::_CalculateArea()
	{

	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_VERTEX4F _MESHTRIANGLE::_GetNormal(const _VERTEX4F &hp)
	{
		
	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	float _GetU(const _DOUBLE beta, const _DOUBLE gamma)
	{
		
	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	float _GetV(const _DOUBLE beta, const _DOUBLE gamma)
	{
	
	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_POINT2D _MESHTRIANGLE::_GetUV(_SHADEREC &sr)
	{

	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_MESHTRIANGLE* _MESHTRIANGLE::_Clone()
	{
		return new _MESHTRIANGLE(*this);
	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	bool _MESHTRIANGLE::_Hit(const _RAY &ray, _DOUBLE &tmin, _SHADEREC &sr)
	{
		return false;
	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	bool _MESHTRIANGLE::_ShadowHit(const _RAY &ray, _DOUBLE &tmin)
	{
		return false;
	}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}